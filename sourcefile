/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   mlx_error_reporting.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yabokhar <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/22 11:33:59 by yabokhar          #+#    #+#             */
/*   Updated: 2025/09/02 10:52:01 by secros           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "miniRT.h"
#include "mlx_struct.h"

void	error_failure_from_mlx_new_image(t_context *scene, t_mlx *display)
{
	mlx_destroy_window(display->mlx_ptr, display->win_ptr);
	mlx_destroy_display(display->mlx_ptr);
	free(display->mlx_ptr);
	ft_lstclear(&scene->objects, free);
	ft_lstclear(&scene->lights_list, free);
	free(scene->threads);
	exit(1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   multithreading_error_malloc.c                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yabokhar <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/22 10:37:03 by yabokhar          #+#    #+#             */
/*   Updated: 2025/08/23 15:31:55 by yabokhar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "miniRT.h"

void	error_malloc_failure_for_threads_array(t_context *scene)

{
	print(2, "Error\nminiRT: malloc: %s\n", strerror(errno));
	ft_lstclear(&scene->objects, free);
	ft_lstclear(&scene->lights_list, free);
	exit(1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_error_reporting_bis.c                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: secros <secros@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/07 16:46:17 by yabokhar          #+#    #+#             */
/*   Updated: 2025/06/18 14:23:55 by secros           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/errors.h"
#include "miniRT.h"

void	excessive_params_error(t_context *scene, const char *element, char n)

{
	const char			*file_name = scene->file_name;
	const unsigned int	line_no = scene->line_number;

	print(2, "%s%s: line %d: *** %s has more than %d parameters\n" \
		, X_ERROR, file_name, line_no, element, n);
	close(scene->fd);
	free(scene->line);
	ft_lstclear(&scene->objects, free);
	exit(1);
}

void	no_space_error(t_context *scene)

{
	const char			*file_name = scene->file_name;
	const unsigned int	line_no = scene->line_number;

	print(2, \
	"%s%s: line %d: *** parameters must be separated by a space\n", \
	X_ERROR, file_name, line_no);
	close(scene->fd);
	free(scene->line);
	ft_lstclear(&scene->objects, free);
	exit(1);
}

void	no_comma_error(t_context *scene)

{
	const char			*file_name = scene->file_name;
	const unsigned int	line_no = scene->line_number;

	print(2, \
	"%s%s: line %d: *** parameters values must be separated by a comma\n", \
	X_ERROR, file_name, line_no);
	close(scene->fd);
	free(scene->line);
	ft_lstclear(&scene->objects, free);
	exit(1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_error_reporting.c                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yabokhar <yabokhar@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/07 16:46:17 by yabokhar          #+#    #+#             */
/*   Updated: 2025/06/16 11:42:38 by yabokhar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/errors.h"
#include "miniRT.h"

void	print_error_then_exit_failure(const char *error_description)

{
	print(2, "%s%s", X_ERROR, error_description);
	exit(1);
}

void	print_error_from_open_function_then_exit_failure(const char *path)

{
	print(2, "%s%s: %s\n", X_ERROR, path, strerror(errno));
	exit(1);
}

void	multiple_declarations_error(t_context *scene, const char *element)

{
	const char			*file_name = scene->file_name;
	const unsigned int	line_no = scene->line_number;

	print(2, \
	"%s%s: line %d: *** multiple declarations of general element %s\n", \
	X_ERROR, file_name, line_no, element);
	close(scene->fd);
	free(scene->line);
	ft_lstclear(&scene->objects, free);
	exit(1);
}

void	precision_lost_error(t_context *scene, const char *elem, const char *p)

{
	const char			*file_name = scene->file_name;
	const unsigned int	line_no = scene->line_number;

	print(2, \
	"%s%s: line %d: *** %s %s precision lost (too many digits)\n", \
	X_ERROR, file_name, line_no, elem, p);
	close(scene->fd);
	free(scene->line);
	ft_lstclear(&scene->objects, free);
	exit(1);
}

void	range_error(t_context *scene, const char *elem, char *min, char *max)

{
	const char			*file_name = scene->file_name;
	const unsigned int	line_no = scene->line_number;

	print(2, \
	"%s%s: line %d: *** %s must be in range [%s,%s]\n", \
	X_ERROR, file_name, line_no, elem, min, max);
	close(scene->fd);
	free(scene->line);
	ft_lstclear(&scene->objects, free);
	exit(1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_camera.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: secros <secros@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/18 19:43:52 by yabokhar          #+#    #+#             */
/*   Updated: 2025/10/06 19:50:20 by secros           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

#define W 0
#define H 1
#define U 0
#define V 1
#include "vect3.h"
#include "miniRT.h"
#include "debug.h"

void	get_pixel_zero(t_viewport *params)
{
	const t_vect3	sum = vect3_add(params->pixel_deltas[U], \
	params->pixel_deltas[V]);
	const t_vect3	div = vect3_const_div(sum, 2);

	params->pixel_zero = vect3_add(params->viewport_upper_left, div);
}

void	get_viewport_upper_left(t_viewport *params, t_camera *cam)
{
	const t_vect3	u = vect3_const_div(params->viewport_vect[U], 2);
	const t_vect3	v = vect3_const_div(params->viewport_vect[V], 2);
	t_vect3			position;

	position = vect3_add(cam->view_point, cam->focal);
	position = vect3_sub(position, v);
	position = vect3_sub(position, u);
	params->viewport_upper_left = position;
}

t_vect3	get_focal(int fov, double size, t_vect3 orientation)
{
	t_vect3			focal;
	const double	demi_lenght = size / 2;
	const double	alpha = (double)(fov) / 2 * M_PI / 180;
	const double	focal_lenght = demi_lenght / tan(alpha);

	ft_fbzero(&focal, sizeof(t_vect3));
	focal = vect3_const_mult(orientation, focal_lenght);
	return (focal);
}

void	get_camera(t_camera	*params, short img[2])
{
	const t_vect3	norm_orientation = vect3_unit(params->orientation_vector);
	t_viewport		*screen;
	t_vect3			world_up;
	t_vect3			u;
	t_vect3			v;

	world_up = (t_vect3){{0, 1, 0}};
	screen = &params->viewport;
	screen->viewport[H] = 2;
	screen->viewport[W] = screen->viewport[H] * img[W] / img[H];
	params->focal = get_focal(params->horizontal_fov, screen->viewport[W], \
		params->orientation_vector);
	if (fabs(norm_orientation.y) >= 0.999)
		world_up = (t_vect3){{0, 0, 1}};
	u = vect3_unit(vect3_cross(world_up, norm_orientation));
	v = vect3_cross(norm_orientation, u);
	screen->viewport_vect[U] = vect3_const_mult(u, screen->viewport[U]);
	screen->viewport_vect[V] = vect3_const_mult(v, -screen->viewport[V]);
	screen->pixel_deltas[U] = vect3_const_div(screen->viewport_vect[U], img[W]);
	screen->pixel_deltas[V] = vect3_const_div(screen->viewport_vect[V], img[H]);
	get_viewport_upper_left(screen, params);
	get_pixel_zero(screen);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   add_element.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yabokhar <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/21 17:32:23 by yabokhar          #+#    #+#             */
/*   Updated: 2025/09/01 16:52:48 by secros           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "miniRT.h"
#include "libft.h"

bool	add_element(t_context *scene, void *type)

{
	t_list	*new_element;

	if (!type)
		return (false);
	new_element = ft_lstnew(type);
	if (!new_element)
	{
		free(type);
		return (false);
	}
	ft_lstadd_back(&scene->lights_list, new_element);
	return (true);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   mlx_display.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: secros <secros@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/02 10:28:46 by secros            #+#    #+#             */
/*   Updated: 2025/09/29 11:54:34 by secros           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "miniRT.h"
#include "mlx_struct.h"
#include "mlx_int.h"

#define W 0
#define H 1

static bool	new_image(t_context *scene, short img[2])
{
	t_mlx	*display;
	t_pict	*new;

	display = &scene->screen_ptr;
	new = &display->img;
	(void)img;
	new->img_ptr = mlx_new_image(display->mlx_ptr, img[W], img[H]);
	if (!new->img_ptr)
		error_failure_from_mlx_new_image(scene, display);
	new->addr = mlx_get_data_addr(new->img_ptr, &new->bbp, &new->l_size, \
		&new->endian);
	if (!new->addr)
	{
		destroy_display(scene);
		return (false);
	}
	return (true);
}

static bool	get_display(t_context *scene, short img[2])
{
	t_mlx	*new;

	new = &scene->screen_ptr;
	ft_fbzero(new, sizeof(t_mlx));
	new->mlx_ptr = mlx_init();
	if (!new->mlx_ptr)
		return (false);
	new->win_ptr = mlx_new_window(new->mlx_ptr, img[W], img[H], "miniRT");
	if (!new->win_ptr)
	{
		mlx_destroy_display(new->mlx_ptr);
		free(new->mlx_ptr);
		return (false);
	}
	mlx_hook(new->win_ptr, DestroyNotify, 0, destroy_display, scene);
	return (true);
}

void	get_display_and_new_image(t_context *scene, short img[2])
{
	if (!get_display(scene, img))
	{
		ft_lstclear(&scene->objects, free);
		ft_lstclear(&scene->lights_list, free);
		free(scene->threads);
		exit(1);
	}
	if (!new_image(scene, img))
		mlx_destroy(&scene->screen_ptr);
}

t_pict	*load_image(t_mlx *display, char *addr)
{
	t_pict	*new;

	new = ft_calloc(sizeof(t_pict), 1);
	if (!new)
		return (NULL);
	new->img_ptr = mlx_xpm_file_to_image(display->mlx_ptr, addr, \
									  &new->size[W], &new->size[H]);
	if (!new->img_ptr)
		return (free_and_return_null(new));
	new->addr = mlx_get_data_addr(new->img_ptr, &new->bbp, &new->l_size, \
							   &new->endian);
	if (!new->addr)
	{
		mlx_destroy_image(display->mlx_ptr, new->img_ptr);
		return (free_and_return_null(new));
	}
	// ft_putendl_fd("Hello", 1);
	return (new);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   mlx_event.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: secros <secros@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/18 19:08:53 by yabokhar          #+#    #+#             */
/*   Updated: 2025/10/06 17:07:00 by secros           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "mlx.h"
#include "miniRT.h"
#include "mlx_struct.h"

#define H 0
#define W 1
#define X 0
#define Y 1
#define ESC 65307
#define KEY_W 119
#define KEY_A 97
#define KEY_S 115
#define KEY_D 100
#define KEY_T 116
#define KEY_B 98

void	mlx_destroy(t_mlx *display)
{
	mlx_loop_end(display->mlx_ptr);
	mlx_destroy_window(display->mlx_ptr, display->win_ptr);
	mlx_destroy_image(display->mlx_ptr, display->img.img_ptr);
	mlx_destroy_display(display->mlx_ptr);
	free(display->mlx_ptr);
}

int	destroy_display(t_context *scene)
{
	mlx_destroy(&scene->screen_ptr);
	ft_lstclear(&scene->objects, free);
	ft_lstclear(&scene->lights_list, free);
	free(scene->threads);
	exit(1);
}

void	destroy_img(t_pict *img, t_mlx *display)
{
	if (img && img->img_ptr)
		mlx_destroy_image(display->mlx_ptr, img->img_ptr);
	free (img);
}

int	handle_key(int keycode, void *params)
{
	t_mlx		*screen;
	t_context	*scene;

	scene = params;
	screen = &scene->screen_ptr;
	if (keycode == ESC)
		destroy_display(scene);
	if (keycode == KEY_T)
		scene->brut_mode = !scene->brut_mode;
	if (keycode == KEY_W || keycode == KEY_A || \
		keycode == KEY_S || keycode == KEY_D)
	{
		move_camera(&scene->camera, keycode);
		get_camera(&scene->camera, scene->img);
	}
	if (keycode == KEY_B)
	{
		print(1, "Time of execution of each thread will be calculated at next frame.\n");
		scene->benchmark = true;
	}
	// get_camera(&scene->camera, scene->img);
	rt(scene);
	mlx_put_image_to_window(screen->mlx_ptr, screen->win_ptr, \
	screen->img.img_ptr, 0, 0);
	return (0);
}

int	handle_mouse(int x, int y, void *params)

{
	t_context	*scene;
	t_mlx		*screen;
	int			centers[2];
	int			directions[2];

	scene = params;
	screen = &scene->screen_ptr;
	centers[X] = scene->img[W] >> 1;
	centers[Y] = scene->img[H] >> 1;
	directions[X] = x - centers[X];
	directions[Y] = y - centers[Y];
	if (directions[X] || directions[Y])
	{
		move_camera_orientation(&scene->camera, directions);
		get_camera(&scene->camera, scene->img);
		rt(scene);
		mlx_put_image_to_window(screen->mlx_ptr, screen->win_ptr, screen->img.img_ptr, 0, 0);
		mlx_mouse_move(screen->mlx_ptr, screen->win_ptr, centers[X], centers[Y]);
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   mlx_helpers.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: secros <secros@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/02 10:58:26 by secros            #+#    #+#             */
/*   Updated: 2025/09/02 15:32:49 by secros           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "mlx_struct.h"

#define W 0
#define H 1

inline static unsigned int	get_color_from_img(t_pict *img, int x, int y)
{
	const char	*addr = img->addr + (y * img->l_size + (x * (img->bbp / 8)));

	return ((*(unsigned int *)addr));
}

t_color	coord_to_img(t_pict	*map, double u, double v)
{
	const int	x_pix = u * (map->size[W] - 1);
	const int	y_pix = v * (map->size[H] - 1);
	t_color		color;

	color.color = get_color_from_img(map, x_pix, y_pix);
	return (color);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cylinder_normal.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yabokhar <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/23 19:00:43 by yabokhar          #+#    #+#             */
/*   Updated: 2025/09/24 17:24:36 by secros           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "miniRT.h"
#include "ray.h"

#define BOT 0
#define TOP 1
#define EPSILON 1e-4
#define T_MIN 1e-6

t_vect3	cylinder_normal(t_cylinder *cy, t_point3 p)
{
	t_vect3			w;
	double			t2;
	t_vect3			q;

	if (fabs(vect3_scalar(vect3_sub(p, cy->bot), cy->orientation)) \
	< EPSILON)
		return (vect3_negate(cy->orientation));
	if (fabs(vect3_scalar(vect3_sub(p, cy->top), cy->orientation)) \
	< EPSILON)
		return (cy->orientation);
	w = vect3_sub(p, cy->pos);
	t2 = vect3_scalar(w, cy->orientation);
	q = vect3_add(cy->pos, vect3_const_mult(cy->orientation, t2));
	return (vect3_unit(vect3_sub(p, q)));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   hit_cone.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: secros <secros@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/04 11:20:18 by secros            #+#    #+#             */
/*   Updated: 2025/10/01 15:33:32 by secros           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "miniRT.h"
#include "ray.h"

#define T_MIN 1e-4
#define EPSILON 1e-6
#define N 0
#define M 1
#define T1 0
#define T2 1
#define A 0
#define B 1
#define C 2

// static double	hit_disk(t_ray r, t_point3 cap_pos, t_vect3 n, double rad)
// {
// 	double	denom;
// 	double	t;
//
// 	denom = vect3_scalar(n, r.direction);
// 	if (denom > -EPSILON && denom < EPSILON)
// 		return (-1);
// 	t = vect3_scalar(n, vect3_sub(cap_pos, r.origin)) / denom;
// 	if (t < T_MIN)
// 		return (-1);
// 	if (vect3_norm(vect3_sub(ray_at(r, t), cap_pos).coords) > rad)
// 		return (-1);
// 	return (t);
// }

double	hit_finit_cone(double hit[2], double scal[2], double height)
{
	double	projected_height;

	projected_height = scal[N] + (hit[T1] * scal[M]);
	if (hit[T1] > T_MIN && projected_height >= -height && projected_height <= height)
		return (hit[T1]);
	projected_height = scal[N] + (hit[T2] * scal[M]);
	if (hit[T2] > T_MIN && projected_height >= -height && projected_height <= height)
		return (hit[T2]);
	return (-1);
}

double	hit_cone_body(t_cone *co, t_ray r)
{
	double			scal[2];
	double			fact[3];
	double			delta;
	double			hit[2];
	const t_vect3	delta_p = vect3_sub(r.origin, co->pos);

	scal[M] = vect3_scalar(r.direction, co->orientation);
	scal[N] = vect3_scalar(delta_p, co->orientation);
	fact[A] = scal[M] * scal[M] - co->k;
	fact[B] = 2 * ((scal[N] * scal[M]) - \
		(vect3_scalar(delta_p, r.direction) * co->k));
	fact[C] = (scal[N] * scal[N]) - (vect3_scalar(delta_p, delta_p) * co->k);
	delta = fact[B] * fact[B] - (4 * fact[A] * fact[C]);
	if (delta < 0)
		return (-1);
	hit[T1] = (-fact[B] - sqrt(delta)) / (2 * fact[A]);
	hit[T2] = (-fact[B] + sqrt(delta)) / (2 * fact[A]);
	if (hit[T1] > hit[T2])
		swap_doubles(&hit[T1], &hit[T2]);
	return (hit_finit_cone(hit, scal, co->height / 2));
}

double	hit_cone(t_cone *co, t_ray r)
{
	double			t_body;
	double			t_cap = 0;

	t_body = hit_cone_body(co, r);
	t_cap = hit_cylinder_caps((t_cylinder *) co, r);
	if (t_body > 0 && t_cap > 0)
	{
		if (t_body < t_cap)
			return (t_body);
		return (t_cap);
	}
	if (t_body > 0)
		return (t_body);
	return (t_cap);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   hit_cylinder.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: secros <secros@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/18 19:16:05 by yabokhar          #+#    #+#             */
/*   Updated: 2025/09/02 11:25:08 by secros           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ray.h"
#include "miniRT.h"
#include "vect3.h"

#define N 0
#define M 1
#define T1 0
#define T2 1
#define A 0
#define B 1
#define C 2
#define EPSILON 1e-4
#define T_MIN 1e-6

static double	hit_disk(t_ray r, t_point3 cap_pos, t_vect3 n, double rad)

{
	double	denom;
	double	t;

	denom = vect3_scalar(n, r.direction);
	if (denom > -EPSILON && denom < EPSILON)
		return (-1);
	t = vect3_scalar(n, vect3_sub(cap_pos, r.origin)) / denom;
	if (t < T_MIN)
		return (-1);
	if (vect3_norm(vect3_sub(ray_at(r, t), cap_pos).coords) > rad)
		return (-1);
	return (t);
}

double	hit_cylinder_caps(t_cylinder *cy, t_ray r)

{
	const double	t1 = hit_disk(r, cy->bot, \
	vect3_negate(cy->orientation), cy->radius);
	const double	t2 = hit_disk(r, cy->top, \
	cy->orientation, cy->radius);

	if (t1 > 0 && (t2 < 0 || t1 < t2))
		return (t1);
	return (t2);
}

double	hit_finite_cylinder(double hit[2], double scal[2], double height)
{
	double	y1;
	double	y2;

	y1 = scal[N] + hit[T1] * scal[M];
	if (hit[T1] > T_MIN && y1 >= -height && y1 <= height)
		return (hit[T1]);
	y2 = scal[N] + hit[T2] * scal[M];
	if (hit[T2] > T_MIN && y2 >= -height && y2 <= height)
		return (hit[T2]);
	return (-1);
}

double	hit_cylinder_body(t_cylinder *cy, t_ray r)
{
	const t_vect3	w = vect3_sub(r.origin, cy->pos);
	double			scal[2];
	double			fact[3];
	double			hit[2];
	double			delta;

	scal[N] = vect3_scalar(w, cy->orientation);
	scal[M] = vect3_scalar(r.direction, cy->orientation);
	fact[A] = 1 - (scal[M] * scal[M]);
	fact[B] = vect3_scalar(w, r.direction) - scal[N] * scal[M];
	fact[C] = vect3_scalar(w, w) - scal[N] * scal[N] - cy->radius * cy->radius;
	delta = fact[B] * fact[B] - fact[A] * fact[C];
	if (delta < 0)
		return (-1);
	hit[T1] = (-fact[B] - sqrt(delta)) / fact[A];
	hit[T2] = (-fact[B] + sqrt(delta)) / fact[A];
	if (hit[T1] > hit[T2])
		swap_doubles(&hit[T1], &hit[T2]);
	return (hit_finite_cylinder(hit, scal, cy->height / 2));
}

double	hit_cylinder(t_cylinder *cy, t_ray r)
{
	double	t_body;
	double	t_caps;

	t_body = hit_cylinder_body(cy, r);
	t_caps = hit_cylinder_caps(cy, r);

	if (t_body > 0 && t_caps > 0)
	{
		if (t_body < t_caps)
			return (t_body);
		return (t_caps);
	}
	if (t_body > 0)
		return (t_body);
	return (t_caps);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   hit_plane.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yabokhar <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/23 19:50:10 by yabokhar          #+#    #+#             */
/*   Updated: 2025/08/27 20:58:49 by yabokhar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ray.h"
#include "miniRT.h"
#include "vect3.h"

#define EPSILON 1e-4
#define T_MIN 1e-6

double	hit_plane(t_plane *plane, t_ray ray)

{
	const double	sum = vect3_scalar(plane->orientation, \
		vect3_sub(plane->pos, ray.origin));
	const double	div = vect3_scalar(plane->orientation, ray.direction);
	double			t;

	if (div < EPSILON && div > -EPSILON)
		return (-1);
	t = sum / div;
	if (t < T_MIN)
		return (-1);
	return (t);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   hit_sphere.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yabokhar <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/23 19:51:12 by yabokhar          #+#    #+#             */
/*   Updated: 2025/10/05 17:33:44 by yabokhar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ray.h"
#include "miniRT.h"
#include "vect3.h"

double	hit_sphere(t_sphere *sphere, t_ray ray)

{
	const t_vect3	oc = vect3_sub(sphere->pos, ray.origin);
	const double	h = vect3_scalar(ray.direction, oc);
	const double	c = vect3_scalar(oc, oc) - sphere->radius * sphere->radius;
	const double	discriminant = h * h - c;

	if (discriminant < 0)
		return (-1);
	const double t1 = h - sqrt(discriminant);
	if (t1 < 0.0)
		return (h + sqrt(discriminant));
	return (t1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   object.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: secros <secros@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/04 16:00:47 by secros            #+#    #+#             */
/*   Updated: 2025/09/24 17:27:56 by secros           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ray.h"
#include "miniRT.h"

double	hit_object(t_object *obj, t_ray r)
{
	if (obj->type == PLANE)
		return (hit_plane((t_plane *) obj, r));
	else if (obj->type == SPHERE)
		return (hit_sphere((t_sphere *) obj, r));
	else if (obj->type == CYLINDER)
		return (hit_cylinder((t_cylinder *) obj, r));
	else if (obj->type == CONE)
		return (hit_cone((t_cone *) obj, r));
	else if (obj->type == CHECKERBOARD)
		return (hit_plane((t_plane *) obj, r));
	return (-1);
} 

t_vect3	object_normal(t_object *obj, t_vect3 p)
{
	t_vect3	normal;

	if (obj->type == PLANE)
		normal = ((t_plane *)obj)->orientation;
	else if (obj->type == SPHERE)
		normal = vect3_unit(vect3_sub(p, obj->pos));
	else if (obj->type == CYLINDER)
		normal = cylinder_normal((t_cylinder *)obj, p);
	else if (obj->type == CHECKERBOARD)
		normal = ((t_plane *)obj)->orientation;
	else
		normal = cone_normal((t_cone *) obj, p);
	return (normal);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   debug.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: secros <secros@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/12 13:24:23 by secros            #+#    #+#             */
/*   Updated: 2025/08/23 17:53:30 by yabokhar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "vect3.h"
#include "miniRT.h"
#include "color.h"
#include <stdio.h>

void	print_vect(void *vect)
{
	t_vect3	print;
	double	*arr;

	print = *((t_vect3 *) vect);
	arr = print.coords;
	printf("Vect3 : %s%f, %f, %f%s", FG_GREEN, arr[0], arr[1], arr[2], RESET);
}

void	print_obj_lst(t_list *head)
{
	t_object	content;
	int			i;

	i = 0;
	while (head)
	{
		i++;
		content = *((t_object *)head->content);
		printf("%dnd Object -->\n", i);
		if (content.type == CYLINDER)
			printf("Type : Cylinder\n");
		if (content.type == SPHERE)
			printf("Type : sphere\n");
		if (content.type == PLANE)
			printf("Type : plane\n");
		printf("Position : ");
		print_vect(&content.pos);
		printf("\nSize : ");
		printf("\nColor : RGB : %s%d, %d, %d%s\n\n", FG_RED, \
		content.color.r, content.color.g, content.color.b, RESET);
		head = head->next;
	}
	printf("END\n\n");
}

void	debug_display_scene_param(t_context *scene)
{
	printf("////DEBUG\\\\\\\\\n");
	printf("Ambient light :RGB = %s%d, %d, %d%s\nRatio :%s%f%s\n\n", \
	FG_RED, scene->ambient_lightning.color.r, \
	scene->ambient_lightning.color.g, scene->ambient_lightning.color.b, \
	RESET, FG_GREEN, scene->ambient_lightning.ratio, RESET);
	printf("Camera :\nViewpoint : %s%f, %f, %f%s,  FOV : %s%d%s\n \
	Orientation : ", FG_GREEN, scene->camera.view_point.coords[0], \
	scene->camera.view_point.coords[1], scene->camera.view_point.coords[2] \
	, RESET, FG_RED, scene->camera.horizontal_fov, RESET);
	print_vect(&scene->camera.orientation_vector);
	printf("\n\nLight :\nBrightness ratio : %s%f%s\nPosition : ", \
	FG_RED, scene->lights.brightness_ratio, RESET);
	print_vect(&scene->lights.light_point);
	printf("\nColor : RGB : %s%d, %d, %d%s\n\n", FG_RED, \
	scene->lights.color.r, scene->lights.color.g, scene->lights.color.b, RESET);
	printf("Obj : \n\n");
	print_obj_lst(scene->objects);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_values.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: secros <secros@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/12 12:43:13 by secros            #+#    #+#             */
/*   Updated: 2025/07/03 11:56:11 by secros           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "miniRT.h"
#include "../../inc/errors.h"

#define X 0
#define Y 1
#define Z 2

static bool	is_negative(char **line);

bool	get_color(t_context *scene, char **line, t_color *color)
{
	int			rgb[3];
	short		i;
	const bool	negative = is_negative(line);

	i = 0;
	ft_bzero(rgb, sizeof(int) * 3);
	while (i < 3 && **line)
	{
		if (!ft_isdigit(**line) && !ft_issign(**line))
			return (false);
		while (**line >= '0' && **line <= '9')
		{
			rgb[i] = rgb[i] * 10 + **line - '0';
			if (rgb[i] > 255 || negative)
				range_error(scene, "colors", "0", "255");
			++(*line);
		}
		if (i < 2 && verify_and_skip_comma(line))
			no_comma_error(scene);
		i++;
	}
	if (i < 3)
		range_error(scene, "colors", "0", "255");
	*color = (t_color){.a = 0, .r = rgb[RED], .g = rgb[GREEN], .b = rgb[BLUE]};
	return (true);
}

static bool	is_negative(char **line)

{
	bool	answer;

	answer = false;
	while (**line == '+' || **line == '-')
	{
		if (**line == '-')
			answer = !(answer);
		++(*line);
	}
	return (answer);
}

bool	get_unique_value(char **line, double *value)
{
	bool	precision;
	char	*end;

	jump_spaces(line);
	*value = ft_strtod(*line, &end, &precision);
	if (end == *line || precision)
		return (1);
	*line = end;
	return (0);
}

bool	get_vect3_value(t_context *scene, char **line, void *element)
{
	short	i;
	double	coord[3];
	bool	precision;
	char	*end;

	i = 0;
	jump_spaces(line);
	ft_bzero(coord, sizeof(double) * 3);
	precision = false;
	while (i < 3 && **line)
	{
		coord[i] = ft_strtod(*line, &end, &precision);
		if (precision || end == *line)
		{
			if (precision)
				precision_lost_error(scene, "object", "coords");
		}
		*line = end;
		if (i < 2 && verify_and_skip_comma(line))
			no_comma_error(scene);
		i++;
	}
	*((t_vect3 *) element) = (t_vect3){{coord[X], coord[Y], coord[Z]}};
	return (true);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_ambient_lightning.c                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: secros <secros@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/03 15:57:00 by yabokhar          #+#    #+#             */
/*   Updated: 2025/09/02 11:43:39 by secros           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "miniRT.h"
#include "libft.h"
#include "../../inc/errors.h"

bool			parse_ambient_lightning(char *line, t_context *scene);
static void		get_ratio(t_context *scene, float *ratio, char **line);

bool	parse_ambient_lightning(char *line, t_context *scene)

{
	t_ambient_lightning	*parameters;

	if (scene->element_has_been_declared[AMBIENT_LIGHTNING])
		multiple_declarations_error(scene, "ambient lightning");
	if (*line != ' ' && *line != '\t')
		no_space_error(scene);
	jump_spaces(&line);
	parameters = &scene->ambient_lightning;
	get_ratio(scene, &parameters->ratio, &line);
	if (*line != ' ' && *line != '\t')
		no_space_error(scene);
	jump_spaces(&line);
	if (!get_color(scene, &line, &parameters->color))
		return (false);
	jump_spaces(&line);
	if (*line != '\n' && *line != '\0')
		excessive_params_error(scene, "ambient lightning", '2');
	return (true);
}

static void	get_ratio(t_context *scene, float *ratio, char **line)
{
	char	*end;
	bool	precision;

	*ratio = (float) ft_strtod(*line, &end, &precision);
	if (end == *line)
		range_error(scene, "ambient lightning", "0.0", "1.0");
	if (precision)
		precision_lost_error(scene, "ambient lightning", "ratio");
	if (!(*ratio >= 0.0 && *ratio <= 1.0))
		range_error(scene, "ambient lightning", "0.0", "1.0");
	*line = end;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_arguments.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yabokhar <yabokhar@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/03 13:33:49 by yabokhar          #+#    #+#             */
/*   Updated: 2025/06/14 20:48:15 by yabokhar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "errors.h"
#define READ_ONLY 0

void		parse_arguments(int argc, const char *argv[], t_context *scene);
static bool	first_argument_is_not_rt(const char *first_argument);
static bool	failed_to_get_valid_fd(const char *path_to_file, t_context *file);
int			open(const char *path, int oflag, ...);
size_t		ft_strlen(const char *s);

void	parse_arguments(int argc, const char *argv[], t_context *file)

{
	if (argc < 2)
		print_error_then_exit_failure("no argument provided\n");
	if (first_argument_is_not_rt(argv[1]))
		print_error_then_exit_failure("invalid file\n");
	if (failed_to_get_valid_fd(argv[1], file))
		print_error_from_open_function_then_exit_failure(argv[1]);
}

static bool	first_argument_is_not_rt(const char *first_argument)

{
	const unsigned short	argument_length = ft_strlen(first_argument);

	if (argument_length < 4)
		return (true);
	if (!ft_strcmp(&first_argument[argument_length - 3], ".rt"))
		return (false);
	return (true);
}

static bool	failed_to_get_valid_fd(const char *path_to_file, t_context *file)

{
	file->fd = open(path_to_file, READ_ONLY);
	if (file->fd < 0)
		return (true);
	file->file_name = (char *)path_to_file;
	return (false);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_camera.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: secros <secros@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/10 15:38:37 by yabokhar          #+#    #+#             */
/*   Updated: 2025/09/02 11:39:21 by secros           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "miniRT.h"
#include "libft.h"
#include "vect3.h"
#include "../../inc/errors.h"
#define PARS_CAMERA_ERR "camera parsing error after setting horizontal fov\n"

bool		parse_camera(char *line, t_context *scene);
static void	get_view_point(t_context *scene, char **line, double p[3], short i);
static bool	get_nov(t_context *scene, char **line, t_vect3 *result);
static void	get_horizontal_fov(t_context *s, char **line, short *horizon_fov);

bool	parse_camera(char *line, t_context *scene)

{
	t_camera	*parameters;

	if (scene->element_has_been_declared[CAMERA])
		multiple_declarations_error(scene, "camera");
	jump_spaces(&line);
	parameters = &scene->camera;
	get_view_point(scene, &line, parameters->view_point.coords, 0);
	if (!get_nov(scene, &line, &parameters->orientation_vector))
		return (false);
	jump_spaces(&line);
	get_horizontal_fov(scene, &line, &parameters->horizontal_fov);
	jump_spaces(&line);
	if (*line != '\0' && *line != '\n' && *line != ' ' && *line != '\t')
		excessive_params_error(scene, "camera", '3');
	return (true);
}

static void	get_view_point(t_context *scene, char **line, double p[3], short i)

{
	char	*end;

	p[i] = ft_strtod(*line, &end, NULL);
	*line = end;
	if (i < 2 && **line != ',')
		no_comma_error(scene);
	else if (**line == ',')
		++(*line);
	if (i < 2)
		get_view_point(scene, line, p, ++i);
	if (i == 2 && **line != ' ' && **line != '\t')
		no_space_error(scene);
}

static bool	get_nov(t_context *scene, char **line, t_vect3 *result)

{
	if (**line == ' ' || **line == '\t')
		(*line)++;
	if (!get_vect3_value(scene, line, result))
		return (false);
	if (result->coords[X] < -1.0 || result->coords[X] > 1.0)
		range_error(scene, "camera 3d normalized orientation vec", "-1", "1");
	if (result->coords[Y] < -1.0 || result->coords[Y] > 1.0)
		range_error(scene, "camera 3d normalized orientation vec", "-1", "1");
	if (result->coords[Z] < -1.0 || result->coords[Z] > 1.0)
		range_error(scene, "camera 3d normalized orientation vec", "-1", "1");
	if (**line != ' ' && **line != '\t')
		no_space_error(scene);
	return (true);
}

static void	get_horizontal_fov(t_context *s, char **line, short *horizon_fov)

{
	if (**line == '-')
		range_error(s, "camera horizontal fov", "0", " ...");
	*horizon_fov = 0;
	if (**line < '0' && **line > '9')
		range_error(s, "camera horizontal fov", "0", "180");
	while (**line >= '0' && **line <= '9')
	{
		*horizon_fov = *horizon_fov * 10 + **line - '0';
		++(*line);
	}
	if (**line != '\0' && **line != '\n' && **line != ' ' && **line != '\t')
		no_space_error(s);
	if (*horizon_fov < 0 || *horizon_fov > 180)
		range_error(s, "camera horizontal fov", "0", "180");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_lights.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: secros <secros@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/10 15:38:43 by yabokhar          #+#    #+#             */
/*   Updated: 2025/09/02 11:34:27 by secros           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "miniRT.h"
#include "libft.h"
#include "../../inc/errors.h"
#include <stdio.h>

bool		parse_light(char *line, t_context *scene);
static bool	get_light_point_coords(t_context *s, char **line, t_point3 *result);
static bool	get_brightness_ratio(t_context *scene, char **line, double *ratio);

bool	parse_light(char *line, t_context *scene)

{
	t_light	*new_light;

	new_light = malloc(sizeof(t_light));
	if (!new_light)
		return (false);
	jump_spaces(&line);
	if (!get_light_point_coords(scene, &line, &new_light->light_point))
		return (false);
	jump_spaces(&line);
	if (!get_brightness_ratio(scene, &line, &new_light->brightness_ratio))
		return (false);
	jump_spaces(&line);
	if (!get_color(scene, &line, &new_light->color))
		return (false);
	jump_spaces(&line);
	if (*line != '\0' && *line != '\n')
		excessive_params_error(scene, "light", '2');
	if (!add_element(scene, new_light))
		return (false);
	scene->lights = *new_light;
	return (true);
}

static bool	get_light_point_coords(t_context *s, char **line, t_point3 *result)

{
	if (!ft_isdigit(**line) && !ft_issign(**line))
		return (false);
	if (!get_vect3_value(s, line, result))
		return (false);
	if (**line != ' ' && **line != '\t')
		no_space_error(s);
	return (true);
}

static bool	get_brightness_ratio(t_context *scene, char **line, double *ratio)

{
	char	*end;
	bool	precision;

	*ratio = ft_strtod(*line, &end, &precision);
	if (*line == end)
		return (false);
	if (*ratio < 0.0 || *ratio > 1.0)
		range_error(scene, "light brightness ratio", "0.0", "1.0");
	if (precision)
		precision_lost_error(scene, "light", "brightness ratio");
	*line = end;
	if (**line != ' ' && **line != '\t')
		no_space_error(scene);
	return (true);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_objects.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: secros <secros@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/06 11:29:39 by secros            #+#    #+#             */
/*   Updated: 2025/10/01 15:32:56 by secros           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "miniRT.h"
#include "libft.h"
#include <stdio.h>
#include "color.h"
#include "debug.h"
#include "vect3.h"

bool	texture_or_color(t_context *scene, t_object *new, char **line)
{
	size_t		id;
	t_vector	*text_list;

	text_list = scene->textures;
	if (**line == 'T' && ft_isdigit(*((*line) + 1)))
	{
		id = ft_atoi(((*line) + 1));
		if (id <= 0 || id > text_list->size)
	  		return (false);
	  	new->text = (t_text*) vector_get_addr(scene->textures, id - 1);
		// printf("Obj color : %d, based color : %d\n", new->color.color, new->text->based.color);
	}
	else
	{
		if (!get_color(scene, line, &new->color))
			return (false);
		new->text = NULL;
	}
	return (true);
}

t_object	*new_plane(t_context *scene, char **line)
{
	t_plane	*new;

	new = malloc(sizeof(t_plane));
	if (!new)
		return (NULL);
	ft_fbzero(new, sizeof(t_plane));
	new->type = PLANE;
	(*line) += 3;
	if (!get_vect3_value(scene, line, &new->pos))
		return (free_and_return_null(new));
	if (!get_vect3_value(scene, line, &new->orientation))
		return (free_and_return_null(new));
	new->orientation = vect3_unit(new->orientation);
	jump_spaces(line);
	if (!texture_or_color(scene, (t_object *)new, line))
		return (free_and_return_null(new));
	return ((t_object *) new);
}

t_object	*new_checkerboard(t_context *scene, char **line)
{
	t_plane	*new;

	new = malloc(sizeof(t_plane));
	if (!new)
		return (NULL);
	ft_fbzero(new, sizeof(t_plane));
	new->type = CHECKERBOARD;
	(*line) += 3;
	if (!get_vect3_value(scene, line, &new->pos))
		return (free_and_return_null(new));
	if (!get_vect3_value(scene, line, &new->orientation))
		return (free_and_return_null(new));
	new->orientation = vect3_unit(new->orientation);
	return ((t_object *) new);
}

static void	precalculate_cylinder_values(t_cylinder *new)

{
	t_vect3			orientation;
	const double	half = new->height * 0.5;
	const t_point3	pos = new->pos;

	new->orientation = vect3_unit(new->orientation);
	orientation = new->orientation;
	new->radius *= 0.5;
	new->bot = vect3_sub(pos, vect3_const_mult(orientation, half));
	new->top = vect3_add(pos, vect3_const_mult(orientation, half));
}

static void	precalculate_cone_values(t_cone *new)
{
	const double	half = new->height / 2;
	new->bot = vect3_sub(new->pos, vect3_const_mult(new->orientation, half));
	new->top = vect3_add(new->pos, vect3_const_mult(new->orientation, half));
	new->k = pow(half, 2) / (pow(half, 2) + pow(new->radius, 2));
}

t_object	*new_cone(t_context *scene, char **line)
{
	t_cone	*new;

	new = malloc(sizeof(t_cone));
	if (!new)
		return (NULL);
	ft_fbzero(new, sizeof(t_cone));
	new->type = CONE;
	(*line) += 3;
	if (!get_vect3_value(scene, line, &new->pos))
		return (free_and_return_null(new));
	if (!get_vect3_value(scene, line, &new->orientation))
		return (free_and_return_null(new));
	new->orientation = vect3_unit(new->orientation);
	if (get_unique_value(line, &new->radius))
		return (free_and_return_null(new));
	new->radius *= 0.5;
	if (get_unique_value(line, &new->height))
		return (free_and_return_null(new));
	jump_spaces(line);
	if (!texture_or_color(scene, (t_object *)new, line))
		return (free_and_return_null(new));
	precalculate_cone_values(new);
	return ((t_object *) new);
}

t_object	*new_cylinder(t_context *scene, char **line)
{
	t_cylinder	*new;

	new = malloc(sizeof(t_cylinder));
	if (!new)
		return (NULL);
	ft_fbzero(new, sizeof(t_cylinder));
	new->type = CYLINDER;
	(*line) += 3;
	if (!get_vect3_value(scene, line, &new->pos))
		return (free_and_return_null(new));
	if (!get_vect3_value(scene, line, &new->orientation))
		return (free_and_return_null(new));
	if (get_unique_value(line, &new->radius))
		return (free_and_return_null(new));
	if (get_unique_value(line, &new->height))
		return (free_and_return_null(new));
	jump_spaces(line);
	if (!texture_or_color(scene, (t_object *)new, line))
		return (free_and_return_null(new));
	precalculate_cylinder_values(new);
	return ((t_object *) new);
}

t_object	*new_sphere(t_context *scene, char **line)
{
	t_sphere	*new;
	double		radius;

	new = malloc(sizeof(t_sphere));
	if (!new)
		return (NULL);
	ft_fbzero(new, sizeof(t_sphere));
	new->type = SPHERE;
	(*line) += 3;
	if (!get_vect3_value(scene, line, &new->pos))
		return (free_and_return_null(new));
	if (get_unique_value(line, &radius))
		return (free_and_return_null(new));
	new->radius = radius * 0.5;
	jump_spaces(line);
	if (!texture_or_color(scene, (t_object *)new, line))
		return (free_and_return_null(new));
	return ((t_object *) new);
}

bool	add_object(t_context *scene, t_object *object)

{
	t_list	*new;

	if (!object)
		return (false);
	new = ft_lstnew((void *)object);
	if (!new)
	{
		free(object);
		return (false);
	}
	ft_lstadd_back(&scene->objects, new);
	return (true);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_parameters.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: secros <secros@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/03 14:29:29 by yabokhar          #+#    #+#             */
/*   Updated: 2025/09/29 12:36:05 by secros           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "get_next_line.h"
#include "miniRT.h"
#include "../../inc/errors.h"

#define MAX_ID 100

void		parse_and_load_parameters(t_context *scene);
static bool	parse_elements(char *line, t_context *scene);
static bool	parse_general_elements(char *line, t_context *scene);
static bool	parse_objects(char *line, t_context *scene);

void	parse_and_load_parameters(t_context *scene)
{
	char	*line;

	line = get_next_line(scene->fd);
	if (!line || !line[0])
	{
		close(scene->fd);
		print_error_then_exit_failure("empty .rt file\n");
	}
	++scene->line_number;
	while (line)
	{
		scene->line = line;
		if (!parse_elements(line, scene))
		{
			close(scene->fd);
			free(line);
			ft_lstclear(&scene->objects, free);
			exit(EXIT_FAILURE);
		}
		free(line);
		line = get_next_line(scene->fd);
		++scene->line_number;
	}
	close(scene->fd);
}

bool	is_space(char c)
{
	if (c == ' ' || c == '\t')
		return (true);
	return (false);
}

#include <stdio.h>

bool	get_path(char **str, char **save_path, t_pict **img)
{
	char	*path;

	jump_spaces(str);
	
	path = extract_str(*str, " \t\n");
	// printf("Curr : %s\npath : %s\n", *str, path);
	if (!path)
		return (false);
	(*str) += ft_strlen(path);
	if (!ft_strncmp(path, "NONE", 5))
	{
		*img = NULL;
		free (path);
		return (true);
	}
	*save_path = path;
	return (true);
}

bool	parse_texture(char *line, t_context *scene)
{
	t_text		new;

	if (*line != 'T' && (!*(line + 1)) && !is_space(*(line + 1)))
		return (false);
	line++;
	ft_fbzero(&new, sizeof(t_text));
	jump_spaces(&line);
	if (!get_color(scene, &line, &new.based))
		return (false);
	if (!get_path(&line, &new.path[0], &new.img[0]))
		return (false);
	if (!get_path(&line, &new.path[1], &new.img[1]))
		return (false);
	jump_spaces(&line);
	if (*line != '\n' && *line)
		return (false);
	// printf("%s\n", new.path[1]);
	vector_push(scene->textures, &new); //TODO Security issue can fail;
	// printf("Based color from pasing : %d img[0] : %p, img[1] : %p\n", new.based.color, (void *)new.img[0], (void *)new.img[1]);
	return (true);
}

static bool	parse_elements(char *line, t_context *scene)

{
	jump_spaces(&line);
	if (*line == '#' || *line == '\n')
		return (true);
	if (parse_general_elements(line, scene))
		return (true);
	else if (parse_texture(line, scene))
		return (true);
	else if (empty_line(line))
		return (true);
	else if (parse_objects(line, scene))
		return (true);
	return (false);
}

static bool	parse_general_elements(char *line, t_context *scene)

{
	if (*line == 'A')
	{
		if (parse_ambient_lightning(line + 1, scene))
			scene->element_has_been_declared[AMBIENT_LIGHTNING] = true;
		return (scene->element_has_been_declared[AMBIENT_LIGHTNING]);
	}
	else if (*line == 'C')
	{
		if (parse_camera(line + 1, scene))
			scene->element_has_been_declared[CAMERA] = true;
		return (scene->element_has_been_declared[CAMERA]);
	}
	else if (*line == 'L')
		return (parse_light(line + 1, scene));
	return (false);
}

static bool	parse_objects(char *line, t_context *scene)
{
	int	error;

	error = 0;
	if (!ft_strncmp("sp", line, 2) && (line[2] == ' ' || line[2] == '\t')) // maybe change it to *(line + 2) for consistency
		error = add_object(scene, new_sphere(scene, &line));
	else if (!ft_strncmp("pl", line, 2) && (line[2] == ' ' || line[2] == '\t'))
		error = add_object(scene, new_plane(scene, &line));
	else if (!ft_strncmp("cy", line, 2) && (line[2] == ' ' || line[2] == '\t'))
		error = add_object(scene, new_cylinder(scene, &line));
	else if (!ft_strncmp("co", line, 2) && (line[2] == ' ' || line[2] == '\t'))
		error = add_object(scene, new_cone(scene, &line));
	else if (!ft_strncmp("ch", line, 2) && (line[2] == ' ' || line[2] == '\t'))
		error = add_object(scene, new_checkerboard(scene, &line));
	else if (!empty_line(line))
		print(2, "%sline %d starts with an unknown identifier\n", \
		X_ERROR, scene->line_number);
	if (!error)
		print(2, "%sline %d Error while parsing an object\n", \
		X_ERROR, scene->line_number);
	return (error);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   process_characters.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yabokhar <yabokhar@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/10 15:38:32 by yabokhar          #+#    #+#             */
/*   Updated: 2025/07/04 11:28:08 by secros           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdbool.h>

int	ft_isdigit(int c);
int	ft_issign(int c);

void	jump_spaces(char **str)
{
	while (**str == ' ' || **str == '\t')
		++(*str);
}

bool	empty_line(char *line)
{
	while ((*line >= '\t' && *line <= '\r') || *line == ' ')
		++line;
	return (*line == '\0' || *line == '\n');
}

bool	verify_and_skip_comma(char **line)
{
	if (**line == ',' && (ft_isdigit(*((*line) + 1))
			|| ft_issign(*((*line) + 1))))
	{
		(*line)++;
		return (false);
	}
	return (true);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   background_shade.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yabokhar <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/23 16:06:16 by yabokhar          #+#    #+#             */
/*   Updated: 2025/08/23 20:10:04 by yabokhar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "miniRT.h"
#include "mlx_struct.h"
#include <math.h>

#define R1 30
#define G1 144
#define B1 144
#define R2 255
#define G2 154
#define B2 154

t_color	bg_shade(double direction_y)

{
	const float	gradient = (1 - cosf(0.5 * (direction_y + 1.0) * M_PI)) / 2.5f;

	return ((t_color){.r = (uint8_t)(R1 + (R2 - R1) * gradient), \
	.g = (uint8_t)(G1 + (G2 - G1) * gradient), \
	.b = (uint8_t)(B1 + (B2 - B1) * gradient), \
	.a = (uint8_t)0});
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   bumpmapping.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: secros <secros@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/02 10:18:09 by secros            #+#    #+#             */
/*   Updated: 2025/10/06 20:10:01 by secros           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "miniRT.h"
#include <math.h>
#include "ray.h"

#define U 0
#define V 1

t_vect3	apply_tbn(t_tbn tbn, t_vect3 normal)
{
	t_vect3	result;

	result.x = tbn.tangent.x * normal.x + \
			tbn.bitangent.x * normal.y + \
			tbn.normal.x * normal.z;
	result.y = tbn.tangent.y * normal.x + \
			tbn.bitangent.y * normal.y +\
			tbn.normal.y * normal.z;
	result.z = tbn.tangent.z * normal.x + \
			tbn.bitangent.z * normal.y +\
			tbn.normal.z * normal.z;
	return (vect3_unit(result));
}

t_vect3	get_normal_map(t_pict *map, double u, double v)
{
	t_vect3		normal;

	normal = color_to_vec(coord_to_img(map, u, v));
	normal = vect3_const_mult(normal, 2);
	normal = vect3_add(normal, (t_vect3) {{-1, -1, -1}});
	return (vect3_unit(normal));
}

t_tbn	compute_sphere_tbn(double u, double v, t_vect3 normal)
{
	t_tbn	sp_tbn;

	sp_tbn.tangent = (t_vect3) {{-sin(2 * M_PI * u), 0, cos(2 * M_PI * u)}};
	sp_tbn.tangent = vect3_unit(sp_tbn.tangent);
	sp_tbn.bitangent = (t_vect3) {{-cos(2 * M_PI * u) * sin(M_PI * v), \
		cos(M_PI * v), -sin(2 * M_PI * u) * sin(M_PI * v)}};
	sp_tbn.bitangent = vect3_unit(sp_tbn.bitangent);
	sp_tbn.normal = normal;
	return (sp_tbn);
}

t_vect3	set_area_value(t_object *obj, t_vect3 *normal, double value[2], t_tbn matrix)
{
	if (obj->text->img[1])
		*normal = apply_tbn(matrix, get_normal_map(obj->text->img[1], value[U], value[V]));
	if (obj->text->img[0])
		return (color_to_vec(coord_to_img(obj->text->img[0], value[U], value[V])));
	else
		return (color_to_vec(obj->text->based));
}

t_vect3	sphere_mapping(t_object *obj, t_point3 p, t_vect3* normal)
{
	double	u;
	double	v;
	t_vect3	to_center;

	to_center = vect3_sub(p, obj->pos);
	to_center = vect3_const_div(to_center, ((t_sphere *)obj)->radius);
	u = 0.5 + atan2(to_center.z, to_center.x) / (2 * M_PI);
	v = 0.5 - asin(to_center.y) / M_PI;
	return (set_area_value(obj, normal, (double [2]){u, v}, compute_sphere_tbn(u, v, *normal)));
}

t_tbn	compute_plane_tbn(t_vect3 axis_u, t_vect3 axis_v,t_vect3 normal)
{
	t_tbn	pl_tbn;

	pl_tbn.normal = normal;
	pl_tbn.tangent = axis_u;
	pl_tbn.bitangent = axis_v;
	return (pl_tbn);
}

t_vect3	plane_mapping(t_object *obj, t_point3 p, t_vect3 *normal)
{
	t_vect3	axis[2];
	t_vect3	to_point;
	t_vect3	tmp;
	double	u;
	double	v;

	tmp = (t_vect3) {{1, 0, 0}};
	if (fabs(vect3_scalar(*normal, tmp)) > 0.9)
		tmp = (t_vect3) {{0, 1, 0}};
	axis[V] = vect3_unit(vect3_cross(*normal, tmp));
	axis[U] = vect3_cross(*normal, axis[V]);
	to_point = vect3_sub(p, obj->pos);
	u = fmod(vect3_scalar(to_point, axis[U]) / 5, 1.0);
	v = fmod(vect3_scalar(to_point, axis[V]) / 5, 1.0);
	if (u < 0.0)
		u += 1.0;
	if (v < 0.0)
		v += 1.0;
	return (set_area_value(obj, normal, (double [2]){u, v}, compute_plane_tbn(axis[U], axis[V], *normal)));
}

#define EPSILON 1e-4
enum	e_part
{
	MIDDLE,
	TOP,
	BOT,
};

bool	cylinder_part(t_cylinder *obj, double *d, t_point3 p)
{
	t_vect3	v = vect3_sub(p, obj->bot);
	*d = vect3_scalar(v, obj->orientation);
	if (*d > 0 && *d < obj->height)
		return (MIDDLE);
	else if (*d >= obj->height - EPSILON)
		return (TOP);
	else if (*d <= EPSILON)
		return (BOT);
	return (-1);
}

t_vect3	cylinder_mapping(t_object *obj, t_point3 p, t_vect3 *normal)
{
	t_cylinder	*curr;
	double		d;
	double		u, v;
	t_tbn		matrix;
	const bool	part = cylinder_part((t_cylinder *)obj, &d, p);

	curr = (t_cylinder *)obj;
	t_vect3	w = {{0, 1, 0}};
	if (fabs(curr->orientation.y) >= 0.999)
		w = (t_vect3) {{1, 0, 0}};
	t_vect3 Rref = vect3_unit(vect3_cross(w, curr->orientation));
	t_vect3 Fref = vect3_cross(curr->orientation, Rref);
	if (!part)
	{
		v = d / curr->height;
		t_point3 q = vect3_add(curr->bot, vect3_const_mult(curr->orientation, d));
	
		t_vect3	Rvect = vect3_sub(p, q);
		double	xlocal = vect3_scalar(Rvect, Rref);
		double	ylocal = vect3_scalar(Rvect, Fref);
		double	teta = atan2(xlocal, ylocal);
		u = (teta + M_PI) / (2 * M_PI);
		matrix.normal = *normal;
		matrix.bitangent = curr->orientation;
		matrix.tangent = vect3_cross(matrix.bitangent, *normal);
	}
	else
	{
		t_vect3	Vcap;
		if (part == 1)
			Vcap = vect3_sub(p, curr->top);
		else
			Vcap = vect3_sub(p, curr->bot);
		double	xlocal = vect3_scalar(Vcap, Rref);
		double	ylocal = vect3_scalar(Vcap, Fref);
		u = xlocal / (curr->radius * 2) + 0.5;
		v = ylocal / (curr->radius * 2) + 0.5;
		matrix.normal = *normal;
		matrix.tangent = Rref;
		matrix.bitangent = vect3_cross(*normal, Rref);
	}
	return (set_area_value(obj, normal, (double [2]){u,v}, matrix));
}

bool	cone_part(t_cone *obj, t_vect3 p, t_vect3 *apex_to_p, double *d)
{
	*apex_to_p = vect3_sub(p, obj->pos);
	*d = vect3_scalar(*apex_to_p, obj->orientation);
	if (*d >= obj->height / 2 - EPSILON)
		return (TOP);
	else if (*d <= -obj->height / 2 + EPSILON)
		return (BOT);
	else if (*d < obj->height / 2 && *d > -obj->height / 2)
		return (MIDDLE);
	return (-1);
}

t_vect3	cone_mapping(t_object *obj, t_point3 p, t_vect3 *normal)
{
	t_cone	*curr;
	t_vect3	apex_to_p;
	double		l, d;
	double		u, v;
	t_tbn		matrix;
	const bool	part = cone_part((t_cone *)obj, p, &apex_to_p, &d);

	curr = (t_cone *)obj;
	t_vect3	w = {{0, 1, 0}};
	if (fabs(curr->orientation.y) >= 0.999)
		w = (t_vect3) {{1, 0, 0}};
	l = sqrt(pow(curr->height, 2) + pow(curr->radius, 2));
	t_vect3 Rref = vect3_unit(vect3_cross(w, curr->orientation));
	t_vect3 Fref = vect3_cross(curr->orientation, Rref);
	if (!part)
	{
		v = vect3_norm(apex_to_p.coords) / l;
		t_point3 q = vect3_add(curr->pos, vect3_const_mult(curr->orientation, d));

		t_vect3	Rvect = vect3_sub(p, q);
		double	xlocal = vect3_scalar(Rvect, Rref);
		double	ylocal = vect3_scalar(Rvect, Fref);
		double	teta = atan2(xlocal, ylocal);
		u = (teta + M_PI) / (2 * M_PI);
		matrix.normal = *normal;
		matrix.tangent = Fref;
		matrix.bitangent = vect3_cross(matrix.normal, matrix.tangent);
	}
	else
	{
		t_vect3	Vcap;
		if (part == 1)
			Vcap = vect3_sub(p, curr->top);
		else
			Vcap = vect3_sub(p, curr->bot);
		double	xlocal = vect3_scalar(Vcap, Rref);
		double	ylocal = vect3_scalar(Vcap, Fref);
		u = xlocal / (curr->radius * 2) + 0.5;
		v = ylocal / (curr->radius * 2) + 0.5;
		matrix.normal = *normal;
		matrix.tangent = Rref;
		matrix.bitangent = vect3_cross(*normal, Rref);
	}
	return (set_area_value(obj, normal, (double [2]){u,v}, matrix));
}

t_color	get_pixel_color(t_object *obj, t_context *scene, \
	t_point3 p, t_vect3 normal)
{
	t_vect3	texture;

	if (obj->type == SPHERE && obj->text)
		texture = sphere_mapping(obj, p, &normal);
	else if (obj->type == PLANE && obj->text)
		texture = plane_mapping(obj, p, &normal);
	else if (obj->type == CYLINDER && obj->text)
		texture = cylinder_mapping(obj, p, &normal);
	else if (obj->type == CHECKERBOARD)
		texture = checkerboard_mapping(obj, p, &normal);
	else if (obj->type == CONE && obj->text)
		texture = cone_mapping(obj, p, &normal);
	else
		texture = color_to_vec(obj->color); //May be removed for performance
	return (vec_to_color(lightning(scene, p, normal, texture)));
}
#include "miniRT.h"
#include <math.h>

t_vect3		checkerboard_mapping(t_object *obj, t_point3 p, t_vect3 *normal);
static void	compute_uv_axes(t_vect3 normal, t_vect3 *axis_u, t_vect3 *axis_v);

t_vect3	checkerboard_mapping(t_object *obj, t_point3 p, t_vect3 *normal)
{
    t_plane	*pl;
    t_vect3	axis_u;
    t_vect3	axis_v;
    t_vect3	to_point;
    double	du;
	double	dv;

    pl = (t_plane *)obj;
    compute_uv_axes(*normal, &axis_u, &axis_v);
    to_point = vect3_sub(p, pl->pos);
    du = vect3_scalar(to_point, axis_u) / 1.0;
    dv = vect3_scalar(to_point, axis_v) / 1.0;
    if ((((long)floor(du) + (long)floor(dv)) % 2) == 0)
		return (color_to_vec((t_color){.r = 255, .g = 255, .b = 255, .a = 0}));
	return (color_to_vec((t_color){.r = 0, .g = 0, .b = 0, .a = 0}));
}

static void compute_uv_axes(t_vect3 normal, t_vect3 *axis_u, t_vect3 *axis_v)
{
    t_vect3 tmp;
    t_vect3 v;

    tmp = (t_vect3){{1, 0, 0}};
    if (fabs(vect3_scalar(normal, tmp)) > 0.9)
        tmp = (t_vect3){{0, 1, 0}};
    v = vect3_unit(vect3_cross(normal, tmp));
    *axis_v = v;
    *axis_u = vect3_cross(normal, v);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lightning.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yabokhar <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/23 20:18:33 by yabokhar          #+#    #+#             */
/*   Updated: 2025/09/04 16:02:10 by secros           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "miniRT.h"
#include "vect3.h"
#include "ray.h"

#define VIEW 0
#define HALFWAY 1
#define DIFF 0
#define SPEC 1
#define T_MIN 1e-4
#define EPSILON 1e-6

t_vect3		lightning(t_context *scene, \
t_point3 p, t_vect3 n, t_vect3 obj_color);
static bool	in_shadow(const t_list *objs, t_ray ray, double max_dist);

t_vect3	lightning(t_context *scene, t_point3 p, t_vect3 n, t_vect3 obj_color)
{
	t_vect3			total_lightning;
	t_list			*light;
	t_light			*current_light;
	t_vect3			light_dir;
	double			light_dist;
	t_vect3			light_color;
	t_vect3			v_reflections[2];

	ft_fbzero(v_reflections, sizeof(t_vect3) * 2);
	total_lightning = vect3_mult(vect3_const_mult(color_to_vec(\
	scene->ambient_lightning.color), \
	scene->ambient_lightning.ratio), obj_color);
	light = scene->lights_list;
	while (light)
	{
		current_light = light->content;
		light_dir = vect3_sub(current_light->light_point, p);
		light_dist = vect3_norm((double *)light_dir.coords); 
		light_dir = vect3_unit(light_dir);
		light_color = color_to_vec(current_light->color);
		if (!in_shadow(scene->objects, \
		(t_ray){vect3_add(p, vect3_const_mult(n, T_MIN)), light_dir}, light_dist))
		{
			v_reflections[DIFF] = vect3_mult(vect3_const_mult(light_color, \
			current_light->brightness_ratio * \
			fmax(vect3_scalar(n, light_dir), 0.0)), obj_color);
			v_reflections[SPEC] = vect3_const_mult(light_color, \
			current_light->brightness_ratio * \
			pow(fmax(vect3_scalar(n, vect3_unit(vect3_add(light_dir, \
			vect3_unit(vect3_sub(scene->camera.view_point, p))))), 0.0), 42));
			total_lightning = vect3_add(total_lightning, v_reflections[DIFF]);
			total_lightning = vect3_add(total_lightning, v_reflections[SPEC]);
		}
		light = light->next;
	}
	return (total_lightning);
}

static bool	in_shadow(const t_list *objs, t_ray ray, double max_dist)
{
	t_object		*curr;
	double			t;

	while (objs)
	{
		curr = (t_object *)objs->content;
		t = hit_object(curr, ray);
		if (t > T_MIN && t < max_dist)
			return (true);
		objs = objs->next;
	}
	return (false);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ray_at.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yabokhar <yabokhar@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/18 15:28:26 by yabokhar          #+#    #+#             */
/*   Updated: 2025/06/18 16:17:19 by yabokhar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ray.h"
#include "vect3.h"

t_vect3	ray_at(t_ray r, double t)

{
	return (vect3_add(r.origin, vect3_const_mult(r.direction, t)));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ray_color.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yabokhar <yabokhar@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/18 19:20:16 by yabokhar          #+#    #+#             */
/*   Updated: 2025/10/06 19:44:23 by secros           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "miniRT.h"
#include "vect3.h"
#include "ray.h"

#define T_MIN 1e-4
#define DBL_MAX 1.79769e+308

static void	find_closest_object(const t_list *objects, t_ray r, \
t_object **current_object, double *current_t)
{
	t_object	*curr;
	double		t;

	while (objects)
	{
		curr = (t_object *)objects->content;
		t = hit_object(curr, r);	
		if (t > T_MIN && t < *current_t)
		{
			*current_t = t;
			*current_object = curr;
		}
		objects = objects->next;
	}
}

#define EPSILON 1e-4

t_vect3	cone_normal(t_cone *co, t_point3 p)
{
	t_vect3	v;
	double	d;
	t_vect3	normal;

	if (fabs(vect3_scalar(vect3_sub(p, co->bot), co->orientation)) \
	< EPSILON)
		return (vect3_negate(co->orientation));
	if (fabs(vect3_scalar(vect3_sub(p, co->top), co->orientation)) \
	< EPSILON)
		return (co->orientation);

	v = vect3_sub(p, co->pos);
	d = vect3_scalar(v, co->orientation);
	normal = vect3_sub(v, vect3_const_mult(vect3_const_mult(co->orientation, \
						1 + pow(co->radius / co->height, 2)), d));
	return (vect3_unit(normal));
}

static t_ray	compute_reflection_ray(t_point3 p, t_vect3 normal, t_ray incident)

{
	t_vect3	reflect_direction;
	double	cos_theta;

	cos_theta = vect3_scalar(incident.direction, normal);
	reflect_direction = vect3_sub(incident.direction, vect3_const_mult(normal, 2.0 * cos_theta));
	return (ray_create(vect3_add(p, vect3_const_mult(normal, T_MIN)), reflect_direction));
}

t_color	ray_color(t_ray ray, t_context *scene, short depth)
{
	t_object		*closest_obj;
	double			closest_t;
	const t_list	*objs = scene->objects;
	t_point3		p;
	t_vect3			normal;

	t_vect3			texture_color;
	t_ray			reflected_ray;
	t_color			reflected_color;
	t_vect3			reflected_vector;

	closest_obj = NULL;
	closest_t = DBL_MAX;
	find_closest_object(objs, ray, &closest_obj, &closest_t);
	if (!closest_obj)
		return (bg_shade(ray.direction.coords[Y]));
	if (scene->brut_mode)
		return (closest_obj->color);
	p = ray_at(ray, closest_t);
	normal = object_normal(closest_obj, p);	
	const double inside = vect3_scalar(normal, ray.direction);
	if (inside > 0.0)
		normal = vect3_negate(normal);
	texture_color = color_to_vec(get_pixel_color(closest_obj, scene, p, normal));
	if (closest_obj->type == CHECKERBOARD && depth)
	// if (depth)
	{
		reflected_ray = compute_reflection_ray(p, normal, ray);
		reflected_color = ray_color(reflected_ray, scene, depth - 1);
		reflected_vector = color_to_vec(reflected_color);
		texture_color = vect3_add(vect3_const_mult(texture_color, 0.5), vect3_const_mult(reflected_vector, 0.5));
	}
	return (vec_to_color(lightning(scene, p, normal, texture_color)));
	/*return (vec_to_color(lightning(scene, p, normal, \
	color_to_vec(closest_obj->color))));*/
	return (get_pixel_color(closest_obj, scene, p, normal));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ray_create.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yabokhar <yabokhar@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/18 15:26:02 by yabokhar          #+#    #+#             */
/*   Updated: 2025/06/18 16:16:31 by yabokhar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ray.h"
#include "vect3.h"

t_ray	ray_create(t_vect3 origin, t_vect3 direction)

{
	t_ray	r;

	r.origin = origin;
	r.direction = direction;
	return (r);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   move_camera.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yabokhar <yabokhar@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/18 10:08:22 by yabokhar          #+#    #+#             */
/*   Updated: 2025/10/06 20:08:48 by secros           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "miniRT.h"
#define KEY_S 119
#define KEY_A 97
#define KEY_W 115
#define KEY_D 100
#define KEY_T 116
#define MOUSE_SENSITIVITY 0.0001

void	move_camera(t_camera *camera, int keycode)

{
	const double	step = 0.5;
	const t_vect3	up = {{0, 0, 0}};
	t_vect3			right;

	right = vect3_cross(camera->orientation_vector, up);
	if (vect3_norm(right.coords) < 1e-6)
		right = (t_vect3){{1, 0, 0}};
	else
		right = vect3_unit(right);
	if (keycode)
	{
		if (keycode == KEY_W)
			camera->view_point = vect3_add(camera->view_point, \
			vect3_const_mult(camera->orientation_vector, step));
		if (keycode == KEY_S)
			camera->view_point = vect3_sub(camera->view_point, \
			vect3_const_mult(camera->orientation_vector, step));
		if (keycode == KEY_A)
			camera->view_point = vect3_sub(camera->view_point, \
			vect3_const_mult(right, step));
		if (keycode == KEY_D)
			camera->view_point = vect3_add(camera->view_point, \
			vect3_const_mult(right, step));
	}
	camera->orientation_vector = vect3_unit(camera->orientation_vector);
}

void	move_camera_orientation(t_camera *camera, int directions[2])

{
	double			yaw;
	double			pitch;
	t_vect3			forward;
	t_vect3			right;
	t_vect3			up;

	up = (t_vect3){{0, 1, 0}};
	if (fabs(camera->orientation_vector.y) >= 0.999)
		up = (t_vect3) {{1, 0, 0}};
	yaw = directions[X] * MOUSE_SENSITIVITY;
	pitch = directions[Y] * MOUSE_SENSITIVITY;
	forward = camera->orientation_vector;
	right = vect3_unit(vect3_cross(up, forward));
	forward = vect3_rotate(forward, up, -yaw);
	forward = vect3_rotate(forward, right, -pitch);
	camera->orientation_vector = vect3_unit(forward);
}
// spectator_mode.c
#include "miniRT.h"
#include "mlx.h"
#include "mlx_struct.h"
#include <string.h>
#define H 0
#define W 1

void destroy_img(t_pict *img, t_mlx *display) {
    if (img && img->img_ptr) {
        mlx_destroy_image(display->mlx_ptr, img->img_ptr);
        memset(img, 0, sizeof(*img));
    }
}

static bool ensure_lowres_image(t_context *scene) {
    const short scale = scene->spectator_scale > 1 ? scene->spectator_scale : 2;
    const short lw = scene->img[W] / scale > 0 ? scene->img[W] / scale : 1;
    const short lh = scene->img[H] / scale > 0 ? scene->img[H] / scale : 1;

    if (scene->lowres_img.img_ptr && scene->lowres_img.size[W] == lw && scene->lowres_img.size[H] == lh)
        return true;
    destroy_img(&scene->screen_ptr, &scene->lowres_img);
    t_pict n = {0};
    n.imgptr = mlx_new_image(scene->screen_ptr.mlxptr, lw, lh);
    if (!n.imgptr) return false;
    n.addr = mlx_get_data_addr(n.img_ptr, &n.bbp, &n.lsize, &n.endian);
    n.size[W] = lw;
    n.size[H] = lh;
    scene->lowres_img = n;
    return true;
}

static void upscale_nearest(const tpict *src, tpict *dst, short scale) {
    const int lw = src->size[W];
    const int lh = src->size[H];
    const int dw = dst->size[W];
    const int dh = dst->size[H];
    const int s_bpp = src->bbp / 8;
    const int d_bpp = dst->bbp / 8;

    for (int y = 0; y < lh; ++y) {
        const char *srow = src->addr + y * src->lsize;
        for (int x = 0; x < lw; ++x) {
            const unsigned int pix = *(unsigned int *)(srow + x * s_bpp);
            const int X0 = x * scale;
            const int Y0 = y * scale;
            for (int ky = 0; ky < scale && Y0 + ky < dh; ++ky) {
                char *drow = dst->addr + (Y0 + ky) * dst->lsize;
                for (int kx = 0; kx < scale && X0 + kx < dw; ++kx) {
                    *(unsigned int *)(drow + (X0 + kx) * d_bpp) = pix;
                }
            }
        }
    }
}

void render_frame(tcontext *scene) {
    if (!scene->spectator_mode) {
        // Pipeline normal: tracer directement dans limage plein cran
        // rtscene -> mlx_put_image_to_window (dj prsent dans le projet)
        rtscene(scene);
        mlx_put_image_to_window(scene->screenptr.mlxptr, scene->screenptr.winptr,
                                scene->screenptr.img.imgptr, 0, 0);
        return;
    }

    if (!ensure_lowres_image(scene)) {
        // fallback si allocation lowres impossible
        rtscene(scene);
        mlx_put_image_to_window(scene->screenptr.mlxptr, scene->screenptr.winptr,
                                scene->screenptr.img.imgptr, 0, 0);
        return;
    }

    // Sauvegarde des dimensions et du pointeur image cran
    short saved_img[2] = { scene->img[W], scene->img[H] };
    tpict saved_full = scene->screenptr.img;

    // Bascule temporairement le contexte vers limage lowres
    scene->img[W] = scene->lowres_img.size[W];
    scene->img[H] = scene->lowres_img.size[H];
    scene->screenptr.img = scene->lowres_img;

    // Met  jour le viewport pour ces dimensions rduites puis trace
    getcamera(scene->camera, scene->img);
    rtscene(scene);

    // Restaure dimensions et image plein cran
    scene->screenptr.img = saved_full;
    scene->img[W] = saved_img[W];
    scene->img[H] = saved_img[H];
    getcamera(scene->camera, scene->img);

    // Upscale lowres -> plein cran
    upscale_nearest(&scene->lowres_img, &scene->screenptr.img, scene->spectator_scale);

    // Affiche
    mlx_put_image_to_window(scene->screenptr.mlxptr, scene->screenptr.winptr,
                            scene->screenptr.img.imgptr, 0, 0);
}

void spectator_destroy(tcontext *scene) {
    destroy_img(&scene->screenptr, &scene->lowres_img);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free_and_return_null.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yabokhar <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/23 21:27:59 by yabokhar          #+#    #+#             */
/*   Updated: 2025/08/23 21:29:35 by yabokhar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

void	free(void *ptr);

void	*free_and_return_null(void *ptr)

{
	free(ptr);
	return ((void *)0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_bzero_vect3.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yabokhar <yabokhar@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/26 15:10:10 by yabokhar          #+#    #+#             */
/*   Updated: 2025/06/26 15:19:49 by yabokhar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "vect3.h"
#include <stdint.h>

void	ft_bzero_vect3(t_vect3 *self)

{
	self->coords[0] = 0;
	self->coords[1] = 0;
	self->coords[2] = 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   print.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: secros <secros@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/14 20:03:21 by yabokhar          #+#    #+#             */
/*   Updated: 2025/06/18 14:24:44 by secros           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdarg.h>
#include <unistd.h>
#include <stdbool.h>
#include <stdlib.h>
#define BUFFER_SIZE 64

void		print(int fd, const char *format, ...);
static void	fill_character(int fd, char *buffer, short *index, char c);
static void	fill_string(int fd, char *buffer, short *index, const char *s);
static void	fill_number(int fd, char *buffer, short *index, int n);
static void	flush_buffer(int fd, char *buffer, short *index);

void	print(int fd, const char *format, ...)
{
	va_list	arguments;
	char	buffer[BUFFER_SIZE];
	short	index;

	index = 0;
	va_start(arguments, format);
	while (*format)
	{
		if (*format == '%')
		{
			++format;
			if (*format == 's')
				fill_string(fd, &buffer[0], &index, va_arg(arguments, char *));
			else if (*format == 'd')
				fill_number(fd, &buffer[0], &index, va_arg(arguments, int));
			else if (*format == 'f')
				write(2, "TODO lol", 8);
		}
		else
			fill_character(fd, &buffer[0], &index, *format);
		format++;
	}
	flush_buffer(fd, &buffer[0], &index);
	va_end(arguments);
}

static void	fill_character(int fd, char *buffer, short *index, char c)

{
	if (*index >= BUFFER_SIZE)
		flush_buffer(fd, buffer, index);
	buffer[(*index)++] = c;
}

static void	fill_string(int fd, char *buffer, short *index, const char *s)

{
	if (!s)
		s = ("(null)");
	while (*s)
		fill_character(fd, buffer, index, *s++);
}

static void	fill_number(int fd, char *buffer, short *index, int n)

{
	short			i;
	char			temporary_buffer[12];
	unsigned int	abs_n;
	const bool		negative = (n < 0);

	i = 11;
	temporary_buffer[i] = '\0';
	if (n == 0)
		temporary_buffer[--i] = '0';
	abs_n = abs(n);
	while (abs_n > 0)
	{
		temporary_buffer[--i] = (abs_n % 10) + '0';
		abs_n /= 10;
	}
	if (negative)
		temporary_buffer[--i] = '-';
	while (temporary_buffer[i])
		fill_character(fd, buffer, index, temporary_buffer[i++]);
}

static void	flush_buffer(int fd, char *buffer, short *index)

{
	if (*index > 0)
	{
		write(fd, buffer, *index);
		*index = 0;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   swap_doubles.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yabokhar <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/23 18:57:41 by yabokhar          #+#    #+#             */
/*   Updated: 2025/08/23 18:58:21 by yabokhar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

void	swap_doubles(double *v1, double *v2)

{
	const double	temp = *v1;

	*v1 = *v2;
	*v2 = temp;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vect3_convert.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: secros <secros@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/21 17:22:04 by yabokhar          #+#    #+#             */
/*   Updated: 2025/06/26 11:39:50 by secros           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "vect3.h"
#include "mlx_struct.h"
#include <math.h>

t_vect3	color_to_vec(t_color c)

{
	return ((t_vect3){{c.r / 255.0, c.g / 255.0, c.b / 255.0}});
}

t_color	vec_to_color(t_vect3 v)

{
	t_color	c;

	v.coords[X] = fmin(fmax(v.coords[X], 0.0), 1.0) * 255.99;
	v.coords[Y] = fmin(fmax(v.coords[Y], 0.0), 1.0) * 255.99;
	v.coords[Z] = fmin(fmax(v.coords[Z], 0.0), 1.0) * 255.99;
	c.r = v.coords[X];
	c.g = v.coords[Y];
	c.b = v.coords[Z];
	c.a = 0;
	return (c);
}

t_vect3	vect3_rotate(t_vect3 v, t_vect3 axis, double angle)

{
	double	c;
	double	s;

	axis = vect3_unit(axis);
	c = cos(angle);
	s = sin(angle);
	return (vect3_add(
			vect3_const_mult(v, c),
			vect3_add(
				vect3_const_mult(vect3_cross(axis, v), s),
				vect3_const_mult(axis, vect3_scalar(axis, v) * (1 - c))
			)
		));
}
#include "miniRT.h"
#include <math.h>

t_vect3	vect3_rotate(t_vect3 v, t_vect3 axis, double angle)

{
	t_vect3	rot;
	double	c;
	double	s;

	axis = vect3_unit(axis);
	c = cos(angle);
	s = sin(angle);
	rot = vect3_add(
			vect3_const_mult(v, c),
			vect3_add(
				vect3_const_mult(vect3_cross(axis, v), s),
				vect3_const_mult(axis, vect3_scalar(axis, v) * (1 - c))
			)
		);
	return (rot);
}
